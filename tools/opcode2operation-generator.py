import sys
from datetime import datetime
import jinja2
import yaml
import os

def main() -> int:
    if len(sys.argv) != 3:
        raise RuntimeError('Should be 3 args, received ' + str(len(sys.argv)))
    with open(sys.argv[2]) as file:
        full = yaml.safe_load(file)
    instructions = full["instructions"]
    opcodes = set()
    # print(instructions)
    opcodes_arr = ["Inv"] * 255

    # Validating yaml file
    for instruction in instructions:
        # print(instruction)
        old_len = len(opcodes)
        opcodes.add(instruction["fixedvalue"])
        new_len = len(opcodes)
        if (new_len == old_len):
            raise RuntimeError("opcode " + str(instruction["fixedvalue"]) + " repeats")
        opcodes_arr[instruction["fixedvalue"]] = instruction["mnemonic"]
    # print(max(opcodes))
    # @todo #41:90min OP_TO_FORMAT is generated incorrectly. Need to be fixed (add Unknown type for all possible instructions)!
    # @todo #41:90min Generate OperationFormat enum automatically
    tpl = """{{ disclaimer }}
#pragma once
#include <string_view>
namespace chai::interpreter {
enum OperationFormat {
    Unknown,
    N,
    R,
    RR,
    I,
    RI
};
enum Operation {
    Inv = 0,
{% for n, item in enumerate(items, 1) %}
    {{ item.mnemonic }} = {{ item.fixedvalue }},
{% endfor %}
};
constexpr std::string_view OP_TO_STR[] = {
{% for op in operations %}"{{ op }}", {% endfor %}
};
constexpr OperationFormat OP_TO_FORMAT[] = {
N, {% for n, item in enumerate(items, 1) %}{{ item.format }}, {% endfor %}
};
} // namespace chai::interpreter

"""
    content = {
        'disclaimer': '/* This file was automatically generated by the script ' +
            sys.argv[0] + ' at ' + datetime.now().strftime("%d.%m.%Y %H:%M:%S") + ' */',
        'items': instructions,
        'enumerate': enumerate,
        'operations': opcodes_arr
    }
    directory = os.path.dirname(sys.argv[1])
    if not os.path.exists(directory):
        os.makedirs(directory)
    fp = open(sys.argv[1], 'w')
    fp.write(
        jinja2
        .Template(tpl, trim_blocks=True)
        .render(content)
    )
    fp.close()

    return 0

if __name__ == '__main__':
    sys.exit(main())
